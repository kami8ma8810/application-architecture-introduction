# レイヤードアーキテクチャの設計

## レイヤーの役割と責務

### 1. プレゼンテーション層
- 外部からのリクエストを受け付け、レスポンスを返す
- フロントエンドそのものではなく、リクエストの受付処理を担当
- 主な責務：
  - HTTPリクエストの受付
  - リクエストのバリデーション
  - エラーハンドリング
  - レスポンスの生成
  - ビジネスロジック層へのデータ受け渡し

### 2. ビジネスロジック層
- アプリケーションの中核となる処理を実装
- ユーザーが求める具体的な処理やビジネスルールを実装
- データアクセス層と連携しながら機能を実現

### 3. データアクセス層
- データベースとのやり取りを担当
- 主な責務：
  - SQLの実行
  - トランザクション管理
  - データの永続化処理

## 書籍管理機能の具体的な設計

### モジュール構成

#### 1. プレゼンテーション層
```typescript
// BookController
class BookController {
  // 書籍に関するHTTPリクエストを処理
  // - POST /books (書籍登録)
  // - GET /books (書籍検索)
  // など
}
```

#### 2. ビジネスロジック層
```typescript
// BookService
class BookService {
  // 書籍に関するビジネスロジックを実装
  // - 書籍登録処理
  // - 書籍検索処理
  // など
}
```

#### 3. データアクセス層
```typescript
// PrismaBookRepository
class PrismaBookRepository {
  // Prisma ORMを使用したデータベースアクセスを実装
  // - 書籍データの保存
  // - 書籍データの検索
  // など
}
```

### ディレクトリ構成
```
src/
├── presentation/
│   └── controllers/
│       └── BookController.ts
├── business/
│   └── services/
│       └── BookService.ts
└── data/
    └── repositories/
        └── PrismaBookRepository.ts
```

## 設計のポイント

### 1. 層の責務の明確な分離
- 各層の責務を越えたコードを書かない
- 避けるべき例：
  - プレゼンテーション層でのビジネスロジックの実装
  - ビジネスロジック層での直接的なデータベースアクセス
  - 層を飛び越えた処理の実装

### 2. 適切な粒度でのモジュール分割
- 機能的なまとまりを意識
- 分割の例：
  - 適切な粒度：書籍管理機能として一つのまとまり
  - 細かすぎる分割：書籍の検索と登録を別々のサービスに分ける
  - 大きすぎる分割：書籍管理と貸出管理を一つのサービスにまとめる

## 実装時の注意点

### 1. 層間の依存関係
- 上位層は下位層にのみ依存可能
- 下位層は上位層を知らない設計を維持

### 2. インターフェースの活用
```typescript
// インターフェース定義
interface BookRepository {
  save(book: Book): Promise<void>;
  findById(id: string): Promise<Book>;
  // ...
}

// 実装クラス
class PrismaBookRepository implements BookRepository {
  // インターフェースの実装
}
```

### 3. 責務の明確化
- 各クラスの役割を明確に定義
- 単一責任の原則を意識した実装

## まとめ
- レイヤードアーキテクチャは各層の責務を明確に分離
- 適切な粒度でのモジュール分割が重要
- 層間の依存関係を適切に管理
- インターフェースを活用した疎結合な設計を目指す 